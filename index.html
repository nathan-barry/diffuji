<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>diffuji</title>
        <style>
            @import url("https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap");

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: #f5f0e8;
                color: #2a2a2a;
                font-family: "Courier Prime", "Courier New", monospace;
                font-size: 14px;
                line-height: 1.6;
                overflow-x: hidden;
            }

            .receipt {
                width: 40ch;
                max-width: 100%;
                margin: 0 auto;
                padding: 3rem 0;
            }

            .receipt pre {
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: inherit;
                font-size: inherit;
                line-height: inherit;
                color: inherit;
            }

            #canvas-container {
                width: 80vw;
                max-width: 600px;
                aspect-ratio: 1 / 1;
                cursor: grab;
                position: relative;
                left: 50%;
                transform: translateX(-50%);
            }

            #canvas-container:active {
                cursor: grabbing;
            }

            #canvas-container canvas {
                width: 100% !important;
                height: 100% !important;
                display: block;
            }

            .drag-hint {
                position: absolute;
                bottom: 0.5rem;
                left: 50%;
                transform: translateX(-50%);
                font-size: 14px;
                color: #999;
                pointer-events: none;
                transition: opacity 0.5s;
            }

            .photos-section {
                width: 80vw;
                max-width: 600px;
                margin: 1.5rem auto;
                position: relative;
                left: 50%;
                transform: translateX(-50%);
            }

            .photos-section img {
                width: 100%;
                height: auto;
                display: block;
            }
        </style>
    </head>
    <body>
        <div class="receipt">
            <pre>
========================================
  DIFFUJI
========================================
a diffusion powered disposable camera
built at treehacks 2026!
            </pre>

            <div id="canvas-container">
                <span class="drag-hint">[drag to rotate]</span>
            </div>

            <pre>
========================================
  PHOTOS
========================================
  </pre
            >

            <div class="photos-section">
                <img src="assets/photos.png" alt="Photos taken with diffuji" />
            </div>

            <pre>
========================================
  WHAT IS IT?
========================================
diffuji is a disposable camera built
at TreeHacks 2025. a raspberry pi zero
2w with a camera and thermal receipt
printer lives inside a custom housing.

snap a photo, pick a mode, and the
image gets sent to an AI backend that
transforms it -- then prints the result
on receipt paper.

========================================
  MODES
========================================
FILTER MODES use diffusion models to
restyle your photos:

  * greek statues
  * studio ghibli style
  * replace everyone with ducks
  * time-travel to different years
  * and more...

SEARCH MODES use perplexity web search
to analyze what the camera sees:

  * estimate price of visible items
  * identify objects and landmarks

========================================
  PROVIDERS
========================================
each request is routed to one of four
AI providers so you can A/B test the
same prompt across different backends:

  [1] OpenAI    (gpt-4o responses api)
  [2] Gemini    (2.5 flash)
  [3] Modal     (flux kontext on h100)
  [4] Perplexity (sonar pro web search)


            treehacks 2026
</pre
            >
        </div>

        <script type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
                }
            }
        </script>

        <script type="module">
            import * as THREE from "three";
            import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
            import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";

            const container = document.getElementById("canvas-container");
            const hint = container.querySelector(".drag-hint");

            const scene = new THREE.Scene();

            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);
            camera.position.set(18, 10, 20);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.06;
            controls.enableZoom = false;
            controls.enablePan = false;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.5;
            controls.minPolarAngle = Math.PI * 0.3;
            controls.maxPolarAngle = Math.PI * 0.7;

            let hinted = false;
            controls.addEventListener("start", () => {
                if (!hinted) {
                    hint.style.opacity = "0";
                    hinted = true;
                }
            });

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const keyLight = new THREE.DirectionalLight(0xffffff, 1.8);
            keyLight.position.set(10, 15, 10);
            scene.add(keyLight);

            const fillLight = new THREE.DirectionalLight(0xaabbff, 0.6);
            fillLight.position.set(-10, 5, -5);
            scene.add(fillLight);

            const rimLight = new THREE.DirectionalLight(0xffeedd, 0.8);
            rimLight.position.set(0, -5, -15);
            scene.add(rimLight);

            const mtlLoader = new MTLLoader();
            mtlLoader.setPath("assets/");
            mtlLoader.load("camera.mtl", (materials) => {
                materials.preload();

                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath("assets/");
                objLoader.load("camera.obj", (object) => {
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0x888888,
                                metalness: 0.4,
                                roughness: 0.4,
                            });
                        }
                    });

                    object.rotation.x = -Math.PI / 2;

                    object.updateMatrixWorld(true);
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);

                    scene.add(object);
                    controls.target.set(0, -1, 0);
                    controls.update();
                });
            });

            function onResize() {
                const w = container.clientWidth;
                const h = container.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            }
            window.addEventListener("resize", onResize);

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        </script>
    </body>
</html>
