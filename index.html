<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>diffuji</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: #000;
                color: #fff;
                font-family: monospace;
                font-size: 14px;
                line-height: 1.6;
                overflow-x: hidden;
            }

            /* Scroll spacer — drives the animation */
            #scroll-spacer {
                height: 600vh;
                position: relative;
            }

            /* 3D viewer stays fixed in center during scroll */
            #viewer {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80vw;
                max-width: 600px;
                aspect-ratio: 1;
                z-index: 10;
                pointer-events: none;
            }
            #viewer canvas {
                width: 100% !important;
                height: 100% !important;
                display: block;
            }

            /* Title overlay */
            #title {
                position: fixed;
                top: 15%;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                z-index: 20;
                pointer-events: none;
                transition: opacity 0.3s;
            }
            #title h1 {
                font-family:
                    -apple-system, BlinkMacSystemFont, "SF Pro Display",
                    "Helvetica Neue", Helvetica, Arial, sans-serif;
                font-size: clamp(2.5rem, 7vw, 5rem);
                font-weight: 600;
                letter-spacing: -0.02em;
            }
            #title p {
                font-family:
                    -apple-system, BlinkMacSystemFont, "SF Pro Display",
                    "Helvetica Neue", Helvetica, Arial, sans-serif;
                color: #666;
                font-weight: 300;
                font-size: 1.1rem;
                letter-spacing: 0.01em;
                margin-top: 0.5rem;
            }

            /* Scroll hint */
            #scroll-hint {
                position: fixed;
                bottom: 2rem;
                left: 50%;
                transform: translateX(-50%);
                color: #444;
                z-index: 20;
                pointer-events: none;
                transition: opacity 0.3s;
                animation: bob 2s ease-in-out infinite;
            }
            @keyframes bob {
                0%,
                100% {
                    transform: translateX(-50%) translateY(0);
                }
                50% {
                    transform: translateX(-50%) translateY(6px);
                }
            }

            /* Receipt paper — emerges from behind camera */
            #receipt-wrapper {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translateX(-50%);
                width: 44ch;
                max-width: 90vw;
                z-index: 15;
                overflow: hidden;
                pointer-events: none;
            }

            #receipt {
                background: #f5f0e8;
                color: #2a2a2a;
                font-family: monospace;
                font-size: 14px;
                line-height: 1.6;
                padding: 2rem 2ch;
                transform: translateY(-100%);
            }

            #receipt pre {
                font: inherit;
                white-space: pre-wrap;
                word-wrap: break-word;
            }
            #receipt a {
                color: #2a2a2a;
            }

            #receipt #photos {
                margin: 0.5rem 0;
            }
            #receipt #photos img {
                width: 100%;
                display: block;
            }

            /* Once scroll is done, unfix everything and let receipt flow */
            .scrolled-past #viewer {
                position: absolute;
                top: auto;
                bottom: 0;
            }
        </style>
    </head>
    <body>
        <!-- This tall div drives the scroll animation -->
        <div id="scroll-spacer"></div>

        <div id="title">
            <h1>diffuji</h1>
            <p>a diffusion powered disposable camera</p>
        </div>

        <div id="scroll-hint">[scroll]</div>

        <div id="viewer"></div>

        <div id="receipt-wrapper">
            <div id="receipt">
                <!-- prettier-ignore -->
                <pre>
========================================
  DIFFUJI
========================================
a diffusion powered disposable camera
built at treehacks 2026!

========================================
  WHAT IS IT?
========================================
diffuji is a disposable camera built
at TreeHacks 2025. a raspberry pi zero
2w with a camera and thermal receipt
printer lives inside a custom housing.

snap a photo, pick a mode, and the
image gets sent to an AI backend that
transforms it -- then prints the result
on receipt paper.
</pre>
                <div id="photos">
                    <img src="assets/photos.png" alt="Photos from diffuji" />
                </div>
                <!-- prettier-ignore -->
                <pre>
========================================
  MODES
========================================
FILTER MODES use diffusion models to
restyle your photos:

  * greek statues
  * studio ghibli style
  * replace everyone with ducks
  * time-travel to different years
  * and more...

SEARCH MODES use perplexity web search
to analyze what the camera sees:

  * estimate price of visible items
  * identify objects and landmarks

each request is routed to one of four
AI providers so you can A/B test the
same prompt across different backends:

  [1] OpenAI    (gpt-4o responses api)
  [2] Gemini    (2.5 flash)
  [3] Modal     (flux kontext on h100)
  [4] Perplexity (sonar pro web search)


========================================
TEAM
========================================

  * <a href="https://nathan.rs">Nathan Barry</a>
  * <a href="https://alexkranias.com">Alex Kranias</a>
  * <a href="https://pranav.cc/">Pranav Tadepalli</a>
  * <a href="https://laineylabs.com/">Lainey Leslie</a>


            treehacks 2026
</pre>
            </div>
        </div>

        <script type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
                }
            }
        </script>
        <script type="module">
            import * as THREE from "three";
            import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
            import { MTLLoader } from "three/addons/loaders/MTLLoader.js";

            const el = document.getElementById("viewer");
            const title = document.getElementById("title");
            const scrollHint = document.getElementById("scroll-hint");
            const receiptWrapper = document.getElementById("receipt-wrapper");
            const receipt = document.getElementById("receipt");
            const spacer = document.getElementById("scroll-spacer");

            const scene = new THREE.Scene();

            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(el.clientWidth, el.clientHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            el.appendChild(renderer.domElement);

            const cam = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);
            cam.position.set(0, 2, 28);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const key = new THREE.DirectionalLight(0xffffff, 1.8);
            key.position.set(10, 15, 10);
            scene.add(key);
            const fill = new THREE.DirectionalLight(0xaabbff, 0.6);
            fill.position.set(-10, 5, -5);
            scene.add(fill);
            const rim = new THREE.DirectionalLight(0xffeedd, 0.8);
            rim.position.set(0, -5, -15);
            scene.add(rim);

            let model = null;

            const mtl = new MTLLoader();
            mtl.setPath("assets/");
            mtl.load("camera.mtl", (mats) => {
                mats.preload();
                const obj = new OBJLoader();
                obj.setMaterials(mats);
                obj.setPath("assets/");
                obj.load("camera.obj", (o) => {
                    o.traverse((c) => {
                        if (c.isMesh)
                            c.material = new THREE.MeshStandardMaterial({
                                color: 0x888888,
                                metalness: 0.4,
                                roughness: 0.4,
                            });
                    });

                    // Stand upright, rotated so lens faces viewer
                    o.rotation.x = -Math.PI / 2;
                    o.rotation.z = -Math.PI / 2;
                    o.updateMatrixWorld(true);

                    // Center
                    const box = new THREE.Box3().setFromObject(o);
                    const center = box.getCenter(new THREE.Vector3());
                    o.position.sub(center);

                    // Wrap in a pivot so we can rotate around Y cleanly
                    const pivot = new THREE.Group();
                    pivot.add(o);
                    scene.add(pivot);
                    model = pivot;
                });
            });

            // Scroll-driven animation
            function onScroll() {
                const maxScroll = spacer.scrollHeight - window.innerHeight;
                const t = Math.max(0, Math.min(1, window.scrollY / maxScroll));

                // Phase 1: 0-0.2 — camera rotates + moves to top + zooms
                // Phase 2: 0.2-0.8 — camera near top, receipt prints out
                // Phase 3: 0.8-1.0 — camera exits up, receipt stays fixed

                const rotateT = Math.min(1, t / 0.2);
                const paperT = Math.max(0, (t - 0.2) / 0.6); // 0-1 over 20%-80%
                const exitT = Math.max(0, (t - 0.8) / 0.2); // 0-1 over 80%-100%

                // Smooth easing for rotation
                const eased =
                    rotateT < 0.5
                        ? 2 * rotateT * rotateT
                        : 1 - Math.pow(-2 * rotateT + 2, 2) / 2;

                if (model) {
                    model.rotation.y = eased * Math.PI;
                }

                // Camera position: 50% -> -20% during rotate, stays there, then exits
                const viewerTop = 50 - eased * 70 - exitT * 40;
                const viewerScale = 1 + eased * 0.5;
                el.style.top = viewerTop + "%";
                el.style.transform = `translate(-50%, -50%) scale(${viewerScale})`;

                // Fade title and scroll hint
                title.style.opacity = Math.max(0, 1 - t * 8);
                scrollHint.style.opacity = Math.max(0, 1 - t * 8);

                // Receipt paper positioning
                const receiptHeight = receipt.offsetHeight;
                const viewerRect = el.getBoundingClientRect();
                const cameraBottom = viewerRect.top + viewerRect.height * 0.8;

                if (exitT > 0) {
                    // Phase 3: receipt stays fixed, camera moves away
                    // Lock receipt wrapper to where it was at start of phase 3
                    if (!receiptWrapper._lockedTop) {
                        receiptWrapper._lockedTop = cameraBottom;
                    }
                    receiptWrapper.style.top = receiptWrapper._lockedTop + "px";
                    receiptWrapper.style.height =
                        window.innerHeight - receiptWrapper._lockedTop + "px";
                } else {
                    // Phase 1-2: receipt follows camera
                    receiptWrapper._lockedTop = null;
                    receiptWrapper.style.top = cameraBottom + "px";
                    receiptWrapper.style.height =
                        window.innerHeight - cameraBottom + "px";
                }

                if (paperT > 0) {
                    receiptWrapper.style.visibility = "visible";
                    receiptWrapper.style.pointerEvents = "auto";
                    const slideAmount = Math.min(1, paperT) * receiptHeight;
                    receipt.style.transform = `translateY(${-receiptHeight + slideAmount}px)`;
                } else {
                    receiptWrapper.style.visibility = "hidden";
                    receiptWrapper.style.pointerEvents = "none";
                    receipt.style.transform = `translateY(-100%)`;
                }
            }

            window.addEventListener("scroll", onScroll, { passive: true });
            window.addEventListener("resize", () => {
                cam.aspect = el.clientWidth / el.clientHeight;
                cam.updateProjectionMatrix();
                renderer.setSize(el.clientWidth, el.clientHeight);
                onScroll();
            });

            onScroll();

            (function loop() {
                requestAnimationFrame(loop);
                renderer.render(scene, cam);
            })();
        </script>
    </body>
</html>
